import sys
from argparse import ArgumentParser
from pathlib import Path


def maybe_warn_snippet(path: Path, *snippets: str) -> str:
    if path.exists():
        dest_text = path.read_text()
    else:
        dest_text = ""
    if any(snippet not in dest_text for snippet in snippets):
        snippet_text = "\n".join(snippets)
        print(
            f"""\
Please add the following snippet to {path.absolute()}:
--------------------------------------------------------------------------------
{snippet_text}
--------------------------------------------------------------------------------
"""
        )
    return dest_text


def main() -> None:
    from versiongit import __version__

    parser = ArgumentParser(
        description="Command line tool adding versiongit to python module"
    )
    parser.add_argument("--version", action="version", version=__version__)
    parser.add_argument("dir", help="The directory to add _version_git.py to")
    args = parser.parse_args()
    package_dir = Path(args.dir)
    assert package_dir.is_dir(), (
        "Expected a python package directory, got %r" % args.dir
    )
    versiongit_path = Path(__file__).absolute().parent
    # Write _version_git.py with descriptive header
    with open(versiongit_path / "_version_git.py") as f:
        lines = f.readlines()
    header = f"""\
# Compute a version number from a git repo or archive

# This file is released into the public domain. Generated by:
# versiongit-{__version__} (https://github.com/dls-controls/versiongit)
"""
    # Make sure when running from git archive or a released version,
    # the format strings are put back in
    for i, line in enumerate(lines):
        split = line.split(" = ")
        if split[0] == "GIT_REFS":
            lines[i] = split[0] + ' = "$Format:%D$"\n'
        elif split[0] == "GIT_SHA1":
            lines[i] = split[0] + ' = "$Format:%h$"\n'
    with open(package_dir / "_version_git.py", "w") as f:
        f.write(header)
        f.writelines(lines)
    print(f"Added {package_dir / '_version_git.py'}\n")
    # Make sure __init__.py lines are in
    maybe_warn_snippet(
        package_dir / "__init__.py", "from ._version_git import __version__",
    )
    # Make sure .gitattribute lines are in
    maybe_warn_snippet(
        package_dir.parent / ".gitattributes", "*/_version_git.py export-subst",
    )
    # Make sure the setup.py lines are in
    txt = maybe_warn_snippet(
        package_dir.parent / "setup.py",
        "# type: ignore",
        "import glob",
        "import importlib.util",
        "",
        "from setuptools import setup",
        "",
        "# Import <package>._version_git.py without importing <package>",
        'path = glob.glob(__file__.replace("setup.py", "*/_version_git.py"))[0]',
        'spec = importlib.util.spec_from_file_location("_version_git", path)',
        "vg = importlib.util.module_from_spec(spec)",
        "spec.loader.exec_module(vg)",
        "",
        "setup(",
        "cmdclass=vg.get_cmdclass(),",
        "version=vg.__version__",
        ")",
    )
    old_method = """\
# Place the directory containing _version_git on the path
for path, _, filenames in os.walk(os.path.dirname(os.path.abspath(__file__))):
    if "_version_git.py" in filenames:
        sys.path.append(path)
        break"""
    if old_method in txt:
        print(
            f"""\
Removing the lines:
--------------------------------------------------------------------------------
{old_method}
--------------------------------------------------------------------------------
"""
        )


# So we can run the file directly for testing
if __name__ == "__main__":  # pragma: no cover
    sys.path.insert(1, str(Path(__file__).parent.parent))
    main()
